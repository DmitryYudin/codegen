#!/usr/bin/env bash

# json-schema-to-typescript@11.0.3  - ok
# json-schema-to-typescript@11.0.4+ - $ref resolve problem
set -eu -o pipefail

DIR_SCRIPT=$(cd "$(dirname "$0")" >/dev/null 2>&1 && pwd)
case ${OS:-} in *_NT) DIR_SCRIPT=$(cygpath -m "$DIR_SCRIPT");; esac

DIR_TMP=${TMP:-/tmp}/_codegen/yaml2jsonschema_ts
case ${OS:-} in *_NT) DIR_TMP=$(cygpath -m "$DIR_TMP");; esac
rm -rf "$DIR_TMP/"; mkdir -p "$DIR_TMP"

usage()
{
    local EXE=$(basename $0)
    cat <<-EOT
Generate typescript validator and types from json schemas described in yaml files

Usage:
    $EXE PATH-TO-SCHEMAS

Options:
    -h,--help           Print this help

    PATH-TO-SCHEMAS     Path to schemas in yaml format (default: cwd)

Dependencies:
    node install -g ajv ajv-cli json-schema-to-typescript@11.0.3

Example:
    $EXE transcoder >transcoder_types.ts
EOT
}

entrypoint()
{
    [[ $# == 0 ]] && usage && exit 1

    local pathToSchemas=
    while [ $# -gt 0 ]; do
        local nargs=1
        case $1 in
            -h|--help) usage && return;;
            *)  [[ -n $pathToSchemas ]] && echo "error: unrecognized option '$1'" >&2 && exit 1
                pathToSchemas=$1
            ;;
        esac
        shift $nargs
    done
    : ${pathToSchemas:=.}

    $DIR_SCRIPT/yaml2json.sh $pathToSchemas $DIR_TMP --id

    local jsonFiles=$(cd "$DIR_TMP" && find . -maxdepth 1 -type f -name "*.json" | sort)
    jsonFiles=$(basename -a $jsonFiles)

    check_schemas "$jsonFiles"
    make_dts "$jsonFiles" |
        filter_dts_duplicates |
        sed '/^export interface Definitions {}$/d'
    make_validators "$jsonFiles" |
        sed '/^    definitions: .*$/d'
}

make_dts()
{
    banner "Generate typescript interfaces"
    local jsonFiles=$1 json= ; shift
    for json in $jsonFiles; do
        json2ts --declareExternallyReferenced --cwd $DIR_TMP $DIR_TMP/$json --bannerComment='' >$DIR_TMP/$json.ts &
    done
    wait-all

    local types=
    for json in $jsonFiles; do
        types=$types$(cat $DIR_TMP/$json.ts)$'\n'
    done
    types=${types%$'\n'}

cat<<EOT
/* eslint-disable */
/* tslint:disable */

/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

$types
EOT
}

filter_dts_duplicates()
{
    awk '
        BEGIN {
            skip = false
        }

        #
        #   Note, we only track INTERFACE definitions
        #       one-liners:
        #           export interface Definitions {}
        #       multiline:
        #           export interface Definitions {
        #               ...
        #           }
        #   but not TYPE definitions:
        #       export type VideoCodecType = ...
        #

        /^export interface .* {/ {
            visited[$3]++
            skip = visited[$3] > 1
        }
        /.*/    {
            if(!skip) print
        }
        /^}/    {
            skip = false
        }

        END {
            # for (i in visited) printf "%3s %s\n", visited[i], i
        }
    '
}

check_schemas()
{
    local jsonFiles=$1; shift

    banner "Check schema is valid (compilable)"
    # rotate list and spilt into [first, ...rest]: *1* 2 3; *2* 3 1; *3* 1 2
    set -- $jsonFiles
    for json in $jsonFiles; do
        shift # pop front
        local refs=
        for ref; do refs="$refs -r $DIR_TMP/$ref"; done
        #ajv compile -s $DIR_TMP/$json $refs -o | command npx js-beautify; >js/$json.js
        ajv compile -s $DIR_TMP/$json $refs --code-optimize=false --strict=false >&2 &
        set -- "$@" $json # push pack
    done
    wait-all
}

make_validators()
{
    local jsonFiles=$1; shift
    jsonFiles=${jsonFiles//.json/}

    banner "Generate module which compile validators at run-time"
    local decl_schemas= add_schemas= validators= deserializers=
    for json in $jsonFiles; do
        local name=${json%.*}
        local typename=$(toCamelCase "$name") schema=
        schema=$(cat $DIR_TMP/$json)

        decl_schemas=$decl_schemas"const $name = $schema"$'\n'
        add_schemas=$add_schemas"ajv.addSchema($name)"$'\n'
        validators=$validators"    $name: ajv.compile<$typename>($name),"$'\n'
        deserializers=$deserializers"    $name: (json:string) => deserialize(json, validators.$name),"$'\n'
    done
    decl_schemas=${decl_schemas%$'\n'}
    add_schemas=${add_schemas%$'\n'}
    validators=${validators%$'\n'}
    deserializers=${deserializers%$'\n'}

    cat <<EOT
/* eslint-disable */
/* tslint:disable */

$decl_schemas

import { default as Ajv, ValidateFunction } from "ajv"

const ajv = new Ajv({strict: false, allErrors: true})
$add_schemas

export const validators = {
$validators
}

function deserialize<T>(json: string, validator: ValidateFunction<T>): T {
    const o = JSON.parse(json)
    if(!validator(o))
        throw Error(ajv.errorsText(validator.errors).split(',').join('\n'))
    return o as T
}

export const deserializers = {
$deserializers
}
EOT
}

banner() {
    echo "#######################################################"
    echo "# $*"
    echo "#######################################################"
} >&2

wait-all() { set -- $(jobs -p); for REPLY; do wait $REPLY; done; }
npx() { command npx --no -- "$@"; }
ajv() { npx ajv "$@"; }
json2ts() { npx json2ts --style.singleQuote --no-style.semi --no-unreachableDefinitions --no-declareExternallyReferenced "$@"; }
toCamelCase() { echo "$1" | sed 's,^\([a-z]\),\U\1,g;s,[_-]\([a-z]\),\U\1,g'; }

SECONDS_START=$(date +%s)
ENTRYPOINT_POST_MESSAGE=done
entrypoint "$@"
echo "$(date +%H:%M:%S -u -d @$(( $(date +%s) - SECONDS_START ))) $ENTRYPOINT_POST_MESSAGE" >&2
